{
	"create_container": "Create Container",
	"create": "Create {{type}}",
	"edit": "Edit {{name}} ",
	"settings": "Settings",
	"builds": "Builds",
	"pods": "Pods",
	"logs": "Logs",
	"events": "Events",
	"variables": "Variables",
	"add_variable": "Add Variable",
	"unsaved_changes": "You have unsaved changes.",
	"pipelineStatus": "Pipeline Status",
	"template": "Template",
	"create_container_from_template": "Create {{type}} from Template",
	"source": {
		"title": "Source",
		"description": "Set up the repository, branch and root folder (if you have a monorepo) of your application source code and Dockerfile that will be cloned and used to build the Docker image. Alternatively you can also provide the public Docker image URL directly.",
		"repoType": "Repository Type",
		"repo": "Source Repo",
		"branch": "Branch",
		"rootDirectory": "Path",
		"watchDirectory": "Watch Path",
		"rootDirectoryHelp": "If you have a monorepo where you maintain code for multiple apps such as backend and frontend then this is the path of the app that you would like to link this deployment to (e.g. /apps/frontend)",
		"watchDirectoryHelp": "If you have a monorepo where you maintain code for multiple apps such as backend and frontend, this is the path you want to set as the watch path for this deployment (e.g. /apps/backend). \n\nIf you want to specify multiple paths, you can separate them with commas (e.g. /apps/backend,/apps/common).",
		"watchPath": "Watch Paths",
		"watchPathHelp": "This are the paths of the source code that Agnost will check for changes to trigger a build. If left empty, it defaults to the Path of the repository specified above.",
		"dockerFile": "Docker File",
		"dockerFileHelp": "The name of the Docker file that will be used to create the Docker image of your app. The Docker file location is relative to the path you have specified above.",
		"connect_git": "Connect {{provider}} Account"
	},
	"registry": {
		"help": "Enter a Docker image from DockerHub, GHCR, or quay.io, e.g., any public docker image registry",
		"image": "Docker Image URL",
		"image_placeholder": "docker.io/nginx:latest",
		"registry": "Image Registry",
		"registry_help": "Select the registry where the image is hosted."
	},
	"general": "General",
	"deployment": {
		"replicas": "Desired Replicas",
		"description": "A deployment helps set up and manage multiple replicas of your application, making sure they run smoothly and update safely without interrupting the service to users.",
		"name": "Deployment Name"
	},
	"stateful": {
		"description": "A StatefulSet is used to manage stateful applications. It ensures that each pod in the set has a unique, stable identity and maintains persistent storage across restarts.",
		"name": "StatefulSet Name",
		"Retain": "Storage is not deleted when the app pod is deleted.",
		"Delete": "Automatically deletes the storage when the app pod is deleted.",
		"retention_policy_delete": "Retention Policy - On Delete",
		"retention_policy_scale": "Retention Policy - On Scale Down"
	},
	"disconnect": "Disconnect your GitHub Account",
	"networking": {
		"title": "Networking",
		"description": "Set up networking for your deployment",
		"container_port": "Container Port",
		"container_port_help": "The port number your application will be listening incoming traffic within the cluster. If you app is a web server, app server or API server etc., this is the port number you app will listening.",
		"private_networking": "Private Networking",
		"private_networking_help": "The port number your application will be listening incoming traffic within the cluster. If you app is a web server, app server or API server etc., this is the port number you app will listening. You can use this internal fully qualified domain name and port to access your app services from other pods running within the cluster.",
		"custom_domain": "Custom Domain",
		"custom_domain_help": "Custom domains allow you to access your deployment from a domain of your choice. You need to have the required authorization to update the DNS settings of the domain that you will be specifying.",
		"tcp_proxy": "TCP Proxy",
		"tcp_proxy_help": "Connect to your app services over TCP using a proxied domain and port. Enabling TCP proxy will forward TCP traffic from clients outside of the cluster to your app services within the cluster.",
		"ingress": "Ingress",
		"ingress_help": "Provide external HTTP or HTTPS access to application services. Agnost provides a path based routing to route incoming traffic to your app services based on the URL path.",
		"show_instructions": "Show DNS configuration instructions",
		"no_domain_warning": "Custom domain and Ingress can only be configured if cluster domain has been set. To set your cluster domain, please visit cluster management section. Please also note that you need to have cluster owner privileges in order to set the cluster domain."
	},
	"pod_config": {
		"title": "Pod Configuration",
		"description": "CPU and memory requests defines the minimum resources each pod needs to start and run smoothly, while limits specify the maximum resources the pod can use to prevent it from using too much and affecting other applications.<1/><1/> 1 Core equals to 1000 millicores, you can specify fractional units in case you use cores. A mebibyte is a unit of measure for memory. It represents 1024 x 1024 bytes. A gigibyte is 1024 mebibytes.",
		"cpu_request": "CPU Request",
		"cpu_limit": "CPU Limit",
		"memory_request": "Memory Request",
		"memory_limit": "Memory Limit",
		"restart_policy": "Restart Policy",
		"Always": "Automatically restarts the container(s) after any termination.",
		"OnFailure": "Only restarts the container if it exits with an error (non-zero exit status).",
		"Never": "Does not automatically restart the terminated container."
	},
	"autoscale": {
		"title": "Autoscale Configuration",
		"description": "Autoscaler automatically adjusts the number of pods in a deployment based on observed metrics like CPU or memory usage. This helps ensure that your application has the necessary resources to perform well without over-provisioning and wasting resources. <1/><1/>When the actual metric of the pods is up or down the target, the autoscaler adjusts the number of replicas in your deployment.",
		"min_replicas": "Minimum Replicas",
		"min_replicas_help": "Cannot be zero",
		"max_replicas": "Maximum Replicas",
		"max_replicas_help": "Maximum number of pods.",
		"cpu_metric": "CPU Metric",
		"memory_metric": "Memory Metric"
	},
	"probes": {
		"title": "Probes",
		"description": "A probe is a diagnostic tool used by the kubelet (the agent that runs on each node in a Kubernetes cluster) to periodically check the status of a container in a pod. Probes are used to determine whether containers are running as expected.",
		"startup": "Startup Probe",
		"startup_help": "Indicates whether the application within the container is started. All other probes are disabled if a startup probe is provided, until it succeeds. If a container does not provide a startup probe, the default state is Success.",
		"liveness": "Liveness Probe",
		"liveness_help": "Indicates whether the application within the container is running. If the liveness probe fails, the kubelet kills the container, and the container is subjected to its restart policy. If a container does not provide a liveness probe, the default state is Success.",
		"readiness": "Readiness Probe",
		"readiness_help": "Indicates whether the container is ready to respond to requests. The default state of readiness before the initial delay is Failure. If a container does not provide a readiness probe,the default state is Success.",
		"check_mechanism": "Check Mechanism",
		"exec": "Execute Command",
		"exec_help": "Executes a specified command inside the container. The diagnostic is considered successful if the command exits with a status code of 0.",
		"httpGet": "HTTP GET",
		"httpGet_help": "Performs an HTTP GET request against the Pod's IP address on a specified port and path. The diagnostic is considered successful if the response has a status code greater than or equal to 200 and less than 400.",
		"tcpSocket": "TCP Socket",
		"tcpSocket_help": "Performs a TCP check against the Pod's IP address on a specified port. The diagnostic is considered successful if the port is open. If the remote system (the container) closes the connection immediately after it opens, this counts as healthy.",
		"initialDelaySeconds": "Initial Delay",
		"initialDelaySeconds_help": "Number of seconds after the container has started before startup.",
		"timeoutSeconds": "Timeout",
		"timeoutSeconds_help": "Number of seconds after which the probe times out.",
		"periodSeconds": "Period",
		"periodSeconds_help": "How often (in seconds) to perform the probe.",
		"failureThreshold": "Failure Threshold",
		"failureThreshold_help": "After a probe fails failure threshold times in a row, <1/>Kubernetes considers that the overall check has failed: the container is not ready/healthy/live.<1/><1/>For the case of a startup or liveness probe, if at least failureThreshold probes have failed, <1/>Kubernetes treats the container as unhealthy and triggers a restart for that specific container.",
		"path": "Path",
		"port": "Port",
		"command_to_execute": "Command to Execute",
		"command": "Command"
	},
	"storage": {
		"title": "Storage",
		"description": "A volume mount refers to the process of making a storage volume accessible to your apps. This allows your app to read from and write to the storage volume, enabling persistent storage beyond the lifecycle of your app container.",
		"mount_path": "Mount Path",
		"storage_size": "Storage Size",
		"reclaim": "Reclaim Policy",
		"accessModes": "Access Modes",
		"ReadWriteOnce": "The storage can be mounted as read-write by a single node. ",
		"ReadOnlyMany": "The storage can be mounted as read-only by many nodes.",
		"ReadWriteMany": "The volume can be mounted as read-write by many nodes.",
		"enable": "Allow pod to access storage"
	},

	"cronjob": {
		"name": "CronJob Name",
		"description": "A cron job is a scheduled task that runs at specified intervals, similar to allows users to automate repetitive tasks such as backups, report generation, or cleanup operations by defining jobs that are executed based on a schedule.",
		"concurrency": "Concurrency Policy",
		"schedule": "Schedule",
		"timezone": "Timezone",
		"suspend": "Suspend",
		"suspend_help": "This flag tells the controller to suspend subsequent executions of the cron job, it does not apply to already started executions.",
		"Allow": "Allows CronJobs to run concurrently.",
		"Forbid": "Forbids concurrent runs, skipping next run if previous run hasn't finished yet.",
		"Replace": "Cancels currently running job and replaces it with a new one."
	},
	"delete": {
		"title": "Delete {{type}}",
		"alert": "Are you sure you want to delete this {{type}}?",
		"description": "This action cannot be undone. This will permanently delete the {{type}} and all of its data.",
		"confirm": "Confirm by typing <confirmCode>{{confirmCode}}</confirmCode> below."
	},
	"pipeline": {
		"triggered": "Triggered By",
		"commit": "Commit",
		"status": "Status",
		"duration": "Duration",
		"back": "Back to Builds"
	},
	"env": {
		"title": "Environment Variables",
		"description": "Environment variables are key-value pairs used to pass configuration information to containers at runtime. They allow you to set dynamic values, such as database credentials, API keys, or application settings, without hardcoding them into your application, enhancing flexibility and security."
	},
	"private": "Private",
	"read_only": "Read Only",
	"view": "View",
	"pod_delete": "Delete Pod",
	"pod_delete_desc": "Are you sure you want to delete this pod?",
	"trigger_build": "Trigger Build & Deploy"
}
